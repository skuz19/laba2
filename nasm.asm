section .data
    prompt_n db "Введите количество чисел: ", 0    ; Инициализируем строку для запроса количества чисел
    prompt_num db "Введите число: ", 0            ; Инициализируем строку для запроса числа
    yes db "YES ", 0                              ; Инициализируем строку для положительного ответа
    no db "NO ", 0                                ; Инициализируем строку для отрицательного ответа
    newline db 10, 0                              ; Инициализируем символ новой строки

section .bss
    n resd 1                                      ; Выделяем 4 байта для хранения количества чисел
    num resd 1                                    ; Выделяем 4 байта для хранения текущего числа
    i resd 1                                      ; Выделяем 4 байта для счетчика цикла
    divider resd 1                                ; Выделяем 4 байта для хранения делителя
    hours resd 1                                  ; Выделяем 4 байта для хранения часов
    minutes resd 1                                ; Выделяем 4 байта для хранения минут
    buffer resb 32                                ; Выделяем 32 байта для буфера ввода

section .text
    global _start                                 ; Объявляем точку входа программы

; Функция вывода строки на экран
print_string:
    mov eax, 4          ; Загружаем номер системного вызова write
    mov ebx, 1          ; Указываем файловый дескриптор stdout
    int 0x80            ; Вызываем прерывание для выполнения вызова
    ret                 ; Возвращаем управление вызывающей функции

; Функция ввода числа с клавиатуры
input_number:
    mov eax, 3          ; Загружаем номер системного вызова read
    mov ebx, 0          ; Указываем файловый дескриптор stdin
    mov ecx, buffer     ; Указываем адрес буфера для ввода
    mov edx, 32         ; Задаем максимальную длину ввода в 32 байта
    int 0x80            ; Вызываем прерывание для выполнения вызова

    ; Преобразуем введенную строку в число
    xor eax, eax        ; Обнуляем регистр EAX для хранения результата
    xor ecx, ecx        ; Обнуляем счетчик символов
    mov esi, buffer     ; Загружаем адрес буфера в ESI
.convert:
    movzx edx, byte [esi+ecx]  ; Загружаем текущий символ из буфера
    cmp dl, 10          ; Проверяем на символ новой строки
    je .done            ; Если конец строки, завершаем преобразование
    sub dl, '0'         ; Преобразуем ASCII-символ в цифру
    imul eax, 10        ; Умножаем текущий результат на 10
    add eax, edx        ; Добавляем текущую цифру к результату
    inc ecx             ; Увеличиваем счетчик символов
    jmp .convert        ; Повторяем для следующего символа
.done:
    ret                 ; Возвращаем результат в EAX

; Функция проверки числа на формат времени
validtime:
    push ebp            ; Сохраняем значение регистра EBP в стеке
    mov ebp, esp        ; Устанавливаем EBP на текущую вершину стека
    mov dword [divider], 1  ; Инициализируем делитель значением 1

.divider_loop:
    cmp dword [divider], 1000  ; Сравниваем делитель с 1000
    jg .return_false    ; Если делитель больше 1000, переходим к возврату false

    ; Делим число на часы и минуты
    mov eax, [ebp+8]    ; Загружаем входное число в EAX
    xor edx, edx        ; Обнуляем EDX для операции деления
    div dword [divider] ; Делим число на делитель
    mov [hours], eax    ; Сохраняем часы
    mov [minutes], edx  ; Сохраняем минуты

    ; Проверяем корректность часов
    cmp dword [hours], 0 ; Сравниваем часы с 0
    jl .next_divider    ; Если часы < 0, пробуем следующий делитель
    cmp dword [hours], 23 ; Сравниваем часы с 23
    jg .next_divider    ; Если часы > 23, пробуем следующий делитель

    ; Проверяем корректность минут
    cmp dword [minutes], 0 ; Сравниваем минуты с 0
    jl .next_divider    ; Если минуты < 0, пробуем следующий делитель
    cmp dword [minutes], 59 ; Сравниваем минуты с 59
    jg .next_divider    ; Если минуты > 59, пробуем следующий делитель

    ; Проверяем допустимые форматы времени
    cmp dword [divider], 1 ; Проверяем формат X:Y
    jne .check_10       ; Если не 1, проверяем следующий формат
    cmp dword [minutes], 10 ; Проверяем однозначные минуты
    jl .return_true     ; Если минуты < 10, формат корректен

.check_10:
    cmp dword [divider], 10 ; Проверяем формат XX:YY
    jne .check_100      ; Если не 10, проверяем следующий формат
    cmp dword [minutes], 100 ; Проверяем двузначные минуты
    jl .return_true     ; Если минуты < 100, формат корректен

.check_100:
    cmp dword [divider], 100 ; Проверяем формат X:YYY
    jne .check_1000     ; Если не 100, проверяем следующий формат
    cmp dword [minutes], 1000 ; Проверяем трехзначные минуты
    jl .return_true     ; Если минуты < 1000, формат корректен

.check_1000:
    cmp dword [divider], 1000 ; Проверяем формат XX:YYY
    jne .next_divider    ; Если не 1000, пробуем следующий делитель
    jmp .return_true     ; Формат корректен

.next_divider:
    mov eax, [divider]   ; Загружаем текущий делитель
    imul eax, 10        ; Умножаем делитель на 10
    mov [divider], eax   ; Сохраняем новый делитель
    jmp .divider_loop   ; Повторяем цикл с новым делителем

.return_true:
    mov eax, 1          ; Устанавливаем флаг успеха
    jmp .end            ; Переходим к завершению функции

.return_false:
    xor eax, eax        ; Устанавливаем флаг ошибки

.end:
    pop ebp             ; Восстанавливаем значение EBP
    ret                 ; Возвращаем управление

; Основная программа
_start:
    ; Запрашиваем количество чисел
    mov ecx, prompt_n   ; Загружаем адрес строки приглашения
    mov edx, 23         ; Указываем длину строки
    call print_string   ; Вызываем функцию вывода

    ; Получаем количество чисел от пользователя
    call input_number   ; Вызываем функцию ввода
    mov [n], eax        ; Сохраняем введенное количество

    ; Инициализируем счетчик цикла
    mov dword [i], 0    ; Устанавливаем начальное значение счетчика

.main_loop:
    ; Проверяем условие завершения цикла
    mov eax, [i]        ; Загружаем текущее значение счетчика
    cmp eax, [n]        ; Сравниваем с количеством чисел
    jge .end_main_loop  ; Если все числа обработаны, выходим из цикла

    ; Запрашиваем число у пользователя
    mov ecx, prompt_num ; Загружаем адрес строки приглашения
    mov edx, 15         ; Указываем длину строки
    call print_string   ; Вызываем функцию вывода

    ; Получаем число от пользователя
    call input_number   ; Вызываем функцию ввода
    mov [num], eax      ; Сохраняем введенное число

    ; Проверяем число на соответствие формату времени
    push dword [num]    ; Передаем число в стек
    call validtime      ; Вызываем функцию проверки
    add esp, 4          ; Очищаем стек после вызова

    ; Выводим результат проверки
    test eax, eax       ; Проверяем результат функции
    jz .print_no        ; Если 0, выводим "NO"

    ; Выводим "YES"
    mov ecx, yes        ; Загружаем адрес строки "YES"
    mov edx, 4          ; Указываем длину строки
    call print_string   ; Вызываем функцию вывода
    jmp .next_iteration ; Переходим к следующей итерации

.print_no:
    ; Выводим "NO"
    mov ecx, no         ; Загружаем адрес строки "NO"
    mov edx, 3          ; Указываем длину строки
    call print_string   ; Вызываем функцию вывода

.next_iteration:
    ; Переходим к следующей итерации
    inc dword [i]       ; Увеличиваем счетчик
    jmp .main_loop      ; Повторяем цикл

.end_main_loop:
    ; Выводим символ новой строки
    mov ecx, newline    ; Загружаем адрес строки с символом новой строки
    mov edx, 1          ; Указываем длину строки
    call print_string   ; Вызываем функцию вывода

    ; Завершаем программу
    mov eax, 1          ; Загружаем номер системного вызова exit
    xor ebx, ebx        ; Устанавливаем код возврата 0
    int 0x80            ; Вызываем прерывание для завершения программы
